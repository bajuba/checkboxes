<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Floating Checkboxes</title>
  <style>
    :root {
      color-scheme: light dark;
      --background: #0b1b2b;
      --panel: rgba(255, 255, 255, 0.08);
      --accent: #7ad7f0;
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at center, rgba(122, 215, 240, 0.1), transparent 45%), var(--background);
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      overflow: hidden;
      min-height: 100vh;
      color: #e9f3ff;
    }

    header {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 18px;
      border-radius: 999px;
      background: var(--panel);
      backdrop-filter: blur(14px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.4px;
    }

    header p {
      margin: 0;
      font-size: 14px;
      opacity: 0.8;
    }

    #scene {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      z-index: 1;
    }

    .guide-line {
      position: fixed;
      left: 0;
      width: 100vw;
      height: 0;
      border-top: 2px dotted rgba(255, 255, 255, 0.35);
      pointer-events: none;
      z-index: 5;
    }

    #emoji-field {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      font-size: 24px;
    }

    #emoji-field .stamp {
      position: absolute;
      transform: translate(-50%, -50%);
      opacity: 0.78;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4));
      user-select: none;
    }

    #pip-panel {
      position: fixed;
      left: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      pointer-events: none;
      z-index: 2;
      font-size: 12px;
      color: rgba(233, 243, 255, 0.85);
    }

    #shop-panel {
      position: fixed;
      right: 16px;
      top: 86px;
      width: 260px;
      padding: 12px;
      border-radius: 14px;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(14px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 6;
      color: #e9f3ff;
    }

    .shop-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .shop-title {
      font-weight: 700;
      letter-spacing: 0.2px;
      font-size: 15px;
    }

    .shop-subtitle {
      font-size: 12px;
      opacity: 0.78;
    }

    .shop-points {
      background: rgba(255, 255, 255, 0.08);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.4px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
      min-width: 70px;
      text-align: right;
    }

    .shop-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 13px;
    }

    .shop-row select {
      flex: 1;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.35);
      color: #e9f3ff;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
    }

    .shop-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .shop-action {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.3);
    }

    .shop-action .label {
      font-weight: 700;
      font-size: 13px;
    }

    .shop-action .hint {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 2px;
    }

    .shop-action button {
      align-self: center;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: linear-gradient(135deg, rgba(122, 215, 240, 0.18), rgba(255, 255, 255, 0.08));
      color: #e9f3ff;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.3);
      transition: transform 120ms ease, filter 120ms ease;
    }

    .shop-action button:hover {
      transform: translateY(-1px);
      filter: brightness(1.08);
    }

    .shop-action button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      filter: grayscale(0.3);
    }

    .pip-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(8px);
    }

    .pip-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .pip-label .swatch {
      width: 12px;
      height: 12px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      flex-shrink: 0;
    }

    .pip-meter {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .pip {
      width: 9px;
      height: 9px;
      border-radius: 3px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      flex-shrink: 0;
      opacity: 0.92;
      filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.35));
    }

    .pip.level-1 { width: 12px; height: 12px; border-radius: 4px; }
    .pip.level-2 { width: 15px; height: 15px; border-radius: 5px; }
    .pip.level-3 { width: 18px; height: 18px; border-radius: 6px; }
    .pip.level-4 { width: 21px; height: 21px; border-radius: 7px; }
    .pip.level-5 { width: 24px; height: 24px; border-radius: 8px; }
    .pip.level-6 { width: 27px; height: 27px; border-radius: 9px; }

    .checkbox {
      position: absolute;
      width: 36px;
      height: 36px;
      display: grid;
      place-items: center;
      transform-origin: center;
      transition: filter 160ms ease;
      pointer-events: auto;
    }

    .checkbox .name-label {
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translate(-50%, -4px);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.2px;
      color: rgba(233, 243, 255, 0.9);
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      white-space: nowrap;
    }

    .checkbox input {
      width: 100%;
      height: 100%;
      accent-color: var(--accent);
      cursor: pointer;
      filter: drop-shadow(0 6px 16px rgba(0, 0, 0, 0.35));
      transform: scale(1.05);
    }

    .checkbox input:checked {
      filter: drop-shadow(0 10px 20px rgba(122, 215, 240, 0.5));
    }

    .checkbox.exploding input {
      filter: drop-shadow(0 10px 24px rgba(255, 77, 79, 0.7));
    }

    .checkbox.overdrive input {
      filter: drop-shadow(0 12px 28px rgba(82, 255, 143, 0.8));
    }

    .checkbox:hover {
      filter: brightness(1.1);
    }

    footer {
      position: fixed;
      bottom: 12px;
      right: 16px;
      padding: 8px 12px;
      background: var(--panel);
      border-radius: 10px;
      font-size: 12px;
      opacity: 0.8;
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
    }
  </style>
</head>
<body>
  <header>
    <h1>Checkbox Swarm</h1>
    <p>Uncheck chaos, check to drop</p>
  </header>
  <div id="emoji-field" aria-hidden="true"></div>
  <div id="scene"></div>
  <div id="pip-panel" aria-hidden="true"></div>
  <div id="shop-panel">
    <div class="shop-header">
      <div>
        <div class="shop-title">Color Workshop</div>
        <div class="shop-subtitle">Spend pips to tune the chaos</div>
      </div>
      <div class="shop-points" id="shop-points">0 pts</div>
    </div>
    <div class="shop-row">
      <label for="color-select">Spend color</label>
      <select id="color-select"></select>
    </div>
    <div class="shop-actions" id="shop-actions"></div>
  </div>
  <div id="guide-top" class="guide-line"></div>
  <div id="guide-bottom" class="guide-line"></div>
  <footer>Checkboxes drift inward, collide, and drop when checked.</footer>

  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    const { Engine, World, Bodies, Body, Runner, Events, Constraint, Vector } = Matter;

    const scene = document.getElementById('scene');
    const engine = Engine.create({ enableSleeping: false });
    const world = engine.world;
    world.gravity.y = 0;

    const runner = Runner.create();

    let viewport = { width: window.innerWidth, height: window.innerHeight };
    let topLimit = viewport.height * 0.1;
    let bottomLimit = viewport.height * 0.9;
    const bodies = new Set();
    let groupId = -1;

    function nextGroup() {
      return groupId--;
    }

    const nameLeft = ['Mighty', 'Swift', 'Brave', 'Silent', 'Wild', 'Cosmic', 'Neon', 'Lucky', 'Nova', 'Echo', 'Frost', 'Aqua', 'Crimson', 'Golden', 'Shadow'];
    const nameRight = ['Badger', 'Falcon', 'Otter', 'Viper', 'Comet', 'Photon', 'Pixel', 'Drifter', 'Quasar', 'Spark', 'Nimbus', 'Ranger', 'Gale', 'Pulse', 'Quill'];

    function randomName() {
      const left = nameLeft[Math.floor(Math.random() * nameLeft.length)];
      const right = nameRight[Math.floor(Math.random() * nameRight.length)];
      return `${left} ${right}`;
    }

    const pipPanel = document.getElementById('pip-panel');
    const pipState = new Map(); // color -> { levels: [counts] }
    const colorLabels = {
      '#7ad7f0': 'Blue',
      '#52ff8f': 'Green',
      '#ff4d4f': 'Red',
      '#ffd166': 'Yellow',
      '#ff66ff': 'Magenta',
      '#66e6ff': 'Cyan'
    };

    const LEVEL_WEIGHTS = [1, 10, 100, 1000, 10000, 100000, 1000000];
    const spentPoints = new Map();
    const shopSelect = document.getElementById('color-select');
    const shopPoints = document.getElementById('shop-points');
    const shopActions = document.getElementById('shop-actions');

    const settings = {
      spawnInterval: 700,
      spawnBurst: 1,
      speedMultiplier: 1,
      spinMultiplier: 1,
      sizeMultiplier: 1,
      explosionMultiplier: 1,
    };

    const upgrades = [
      {
        key: 'spawnBurst',
        label: 'More checkboxes',
        hint: () => `Spawn ${settings.spawnBurst} → ${settings.spawnBurst + 1} per wave`,
        cost: 30,
        apply: () => { settings.spawnBurst = Math.min(settings.spawnBurst + 1, 6); resetSpawner(); },
        canApply: () => settings.spawnBurst < 6,
      },
      {
        key: 'spawnInterval',
        label: 'Faster waves',
        hint: () => `Interval ${Math.round(settings.spawnInterval)}ms → ${Math.max(240, Math.round(settings.spawnInterval * 0.9))}ms`,
        cost: 25,
        apply: () => { settings.spawnInterval = Math.max(240, settings.spawnInterval * 0.9); resetSpawner(); },
        canApply: () => settings.spawnInterval > 250,
      },
      {
        key: 'speedMultiplier',
        label: 'Drift speed',
        hint: () => `Speed x${settings.speedMultiplier.toFixed(2)} → x${(settings.speedMultiplier + 0.15).toFixed(2)}`,
        cost: 20,
        apply: () => { settings.speedMultiplier += 0.15; },
        canApply: () => settings.speedMultiplier < 2.5,
      },
      {
        key: 'spinMultiplier',
        label: 'Spin rate',
        hint: () => `Spin x${settings.spinMultiplier.toFixed(2)} → x${(settings.spinMultiplier + 0.15).toFixed(2)}`,
        cost: 18,
        apply: () => { settings.spinMultiplier += 0.15; },
        canApply: () => settings.spinMultiplier < 2.5,
      },
      {
        key: 'sizeMultiplier',
        label: 'Chunky boxes',
        hint: () => `Size x${settings.sizeMultiplier.toFixed(2)} → x${(settings.sizeMultiplier + 0.1).toFixed(2)}`,
        cost: 22,
        apply: () => { settings.sizeMultiplier = Math.min(settings.sizeMultiplier + 0.1, 2.2); },
        canApply: () => settings.sizeMultiplier < 2.2,
      },
      {
        key: 'explosionMultiplier',
        label: 'Bigger booms',
        hint: () => `Blast x${settings.explosionMultiplier.toFixed(2)} → x${(settings.explosionMultiplier + 0.2).toFixed(2)}`,
        cost: 28,
        apply: () => { settings.explosionMultiplier = Math.min(settings.explosionMultiplier + 0.2, 3); },
        canApply: () => settings.explosionMultiplier < 3,
      },
    ];

    if (shopSelect) {
      shopSelect.addEventListener('change', refreshShop);
    }
    refreshShop();

    const PRIMARY_COLORS = new Set(['#7ad7f0', '#52ff8f', '#ff4d4f']);
    const BASE_COLORS = ['#7ad7f0']; // normal blue spawn
    const MIX_TABLE = {
      '#7ad7f0|#ff4d4f': '#ff66ff', // blue + red -> magenta
      '#7ad7f0|#52ff8f': '#66e6ff', // blue + green -> cyan
      '#52ff8f|#ff4d4f': '#ffd166'  // green + red -> yellow
    };

    function randomBaseColor() {
      return BASE_COLORS[Math.floor(Math.random() * BASE_COLORS.length)];
    }

    function normalizeHex(color) {
      if (!color) return null;
      const raw = color.trim().replace('#', '');
      if (!/^[0-9a-f]{6}$/i.test(raw)) return null;
      return `#${raw.toLowerCase()}`;
    }

    function colorKey(color) {
      return normalizeHex(color) || '';
    }

    function blendKey(a, b) {
      const A = colorKey(a);
      const B = colorKey(b);
      return [A, B].sort().join('|');
    }

    function hexToRgb(color) {
      const hex = colorKey(color);
      if (!hex) return null;
      return {
        r: parseInt(hex.slice(1, 3), 16),
        g: parseInt(hex.slice(3, 5), 16),
        b: parseInt(hex.slice(5, 7), 16)
      };
    }

    function rgbToHex({ r, g, b }) {
      const clamp = (v) => Math.max(0, Math.min(255, Math.round(v)));
      return `#${[clamp(r), clamp(g), clamp(b)].map((v) => v.toString(16).padStart(2, '0')).join('')}`;
    }

    function averageHexColors(a, b) {
      const ca = hexToRgb(a);
      const cb = hexToRgb(b);
      if (!ca || !cb) return null;
      return rgbToHex({
        r: (ca.r + cb.r) / 2,
        g: (ca.g + cb.g) / 2,
        b: (ca.b + cb.b) / 2
      });
    }

    function ensurePipRow(color) {
      if (!pipPanel) return null;
      const key = colorKey(color);
      let row = pipPanel.querySelector(`[data-color="${key}"]`);
      if (row) return row;

      row = document.createElement('div');
      row.className = 'pip-row';
      row.dataset.color = key;

      const label = document.createElement('div');
      label.className = 'pip-label';

      const swatch = document.createElement('span');
      swatch.className = 'swatch';
      swatch.style.background = color;

      const text = document.createElement('span');
      text.textContent = colorLabels[key] || 'Other';

      label.appendChild(swatch);
      label.appendChild(text);

      const meter = document.createElement('div');
      meter.className = 'pip-meter';

      row.appendChild(label);
      row.appendChild(meter);
      pipPanel.appendChild(row);
      return row;
    }

    function ensurePipState(color) {
      const key = colorKey(color);
      if (!pipState.has(key)) {
        pipState.set(key, { levels: Array(7).fill(0) });
      }
      return pipState.get(key);
    }

    function totalPoints(color) {
      const state = ensurePipState(color);
      return state.levels.reduce((sum, count, level) => sum + count * (LEVEL_WEIGHTS[level] || 0), 0);
    }

    function availablePoints(color) {
      const key = colorKey(color);
      const total = totalPoints(key);
      const spent = spentPoints.get(key) || 0;
      return Math.max(0, total - spent);
    }

    function blendColors(a, b) {
      const key = blendKey(a, b);
      if (!key.trim()) return null;
      return MIX_TABLE[key] || null;
    }

    function createBoundary(x, y, w, h, label) {
      return Bodies.rectangle(x, y, w, h, { isStatic: true, label, render: { visible: false } });
    }

    const boundaries = {
      floor: createBoundary(0, 0, 1, 1, 'floor'),
      ceiling: createBoundary(0, 0, 1, 1, 'ceiling'),
      left: createBoundary(0, 0, 1, 1, 'left'),
      right: createBoundary(0, 0, 1, 1, 'right'),
    };

    function positionBoundaries() {
      viewport = { width: window.innerWidth, height: window.innerHeight };
      const { width: w, height: h } = viewport;
      topLimit = h * 0.1;
      bottomLimit = h * 0.9;

      const guideTop = document.getElementById('guide-top');
      const guideBottom = document.getElementById('guide-bottom');
      if (guideTop) guideTop.style.top = `${topLimit}px`;
      if (guideBottom) guideBottom.style.top = `${bottomLimit}px`;
      if (pipPanel) pipPanel.style.top = `${topLimit + 6}px`;

      Body.setPosition(boundaries.floor, { x: w / 2, y: h + 30 });
      Body.setVertices(boundaries.floor, [
        { x: -50, y: h + 15 }, { x: w + 50, y: h + 15 }, { x: w + 50, y: h + 45 }, { x: -50, y: h + 45 }
      ]);

      Body.setPosition(boundaries.ceiling, { x: w / 2, y: -30 });
      Body.setVertices(boundaries.ceiling, [
        { x: -50, y: -45 }, { x: w + 50, y: -45 }, { x: w + 50, y: -15 }, { x: -50, y: -15 }
      ]);

      Body.setPosition(boundaries.left, { x: -30, y: h / 2 });
      Body.setVertices(boundaries.left, [
        { x: -45, y: -50 }, { x: -15, y: -50 }, { x: -15, y: h + 50 }, { x: -45, y: h + 50 }
      ]);

      Body.setPosition(boundaries.right, { x: w + 30, y: h / 2 });
      Body.setVertices(boundaries.right, [
        { x: w + 15, y: -50 }, { x: w + 45, y: -50 }, { x: w + 45, y: h + 50 }, { x: w + 15, y: h + 50 }
      ]);
    }

    positionBoundaries();
    World.add(world, Object.values(boundaries));

    window.addEventListener('resize', positionBoundaries);

    function randomSpawnPosition() {
      const side = Math.floor(Math.random() * 4);
      const margin = 80;
      const { width: w, height: h } = viewport;

      const clampedX = () => Math.min(Math.max(margin, Math.random() * w), w - margin);
      const clampedY = () => Math.min(Math.max(margin, Math.random() * h), h - margin);

      switch (side) {
        case 0: return { x: margin, y: clampedY() }; // left edge, inside view
        case 1: return { x: w - margin, y: clampedY() }; // right edge, inside view
        case 2: return { x: clampedX(), y: margin }; // top edge, inside view
        default: return { x: clampedX(), y: h - margin }; // bottom edge, inside view
      }
    }

    let spawnTimer = null;

    function spawnWave() {
      for (let i = 0; i < settings.spawnBurst; i++) {
        spawnCheckbox();
      }
    }

    function resetSpawner() {
      if (spawnTimer) clearInterval(spawnTimer);
      spawnTimer = setInterval(spawnWave, settings.spawnInterval);
    }

    function spawnCheckbox() {
      const position = randomSpawnPosition();
      const size = (34 + Math.random() * 8) * settings.sizeMultiplier;
      const element = document.createElement('label');
      element.className = 'checkbox';
      element.style.width = `${size}px`;
      element.style.height = `${size}px`;
      const baseColor = randomBaseColor();
      const name = randomName();
      element.title = name;
      element.dataset.name = name;
      const nameLabel = document.createElement('div');
      nameLabel.className = 'name-label';
      nameLabel.textContent = name;
      const input = document.createElement('input');
      input.type = 'checkbox';
      element.appendChild(nameLabel);
      element.appendChild(input);
      scene.appendChild(element);

      const body = Bodies.rectangle(position.x, position.y, size, size, {
        restitution: 0.72,
        friction: 0.005,
        frictionStatic: 0.001,
        frictionAir: 0.012,
        chamfer: 4,
        label: 'checkbox'
      });
      body.plugin = {
        element,
        input,
        isChecked: false,
        isStuck: false,
        isFrozen: false,
        isExploding: false,
        isOverdrive: false,
        size,
        color: baseColor,
        colorLocked: false,
        explosionStart: 0,
        lastExplosion: 0,
        lastBoost: 0,
        canMerge: true
      };

      const center = { x: viewport.width / 2, y: viewport.height / 2 };
      const direction = Vector.normalise({ x: center.x - position.x, y: center.y - position.y });
      const speed = (2 + Math.random() * 2.5) * settings.speedMultiplier;
      Body.setVelocity(body, { x: direction.x * speed, y: direction.y * speed });
      Body.setAngularVelocity(body, (Math.random() - 0.5) * 1.5 * settings.spinMultiplier);

      input.addEventListener('change', () => {
        // Lock once checked; disallow unchecking.
        if (body.plugin.isChecked) {
          input.checked = true;
          return;
        }
        body.plugin.isChecked = true;
        body.plugin.colorLocked = true;
        updateColor(body, body.plugin.color);
        Body.setAngularVelocity(body, body.angularVelocity * 0.4);
        body.frictionAir = 0.02;
        body.friction = 0.001;
        body.frictionStatic = 0.0005;
      });

      bodies.add(body);
      World.add(world, body);
      updateColor(body, baseColor);
    }

    function applyCenterAttraction(body) {
      const center = { x: viewport.width / 2, y: viewport.height / 2 };
      const toCenter = Vector.sub(center, body.position);
      const distance = Vector.magnitude(toCenter) + 0.0001;
      const direction = Vector.mult(toCenter, 1 / distance);
      const force = Vector.mult(direction, 0.00006 * Math.min(distance / 200, 1));
      Body.applyForce(body, body.position, force);
    }

    function updateColor(body, color) {
      const plugin = body.plugin;
      if (!plugin) return;
      const RED = '#ff4d4f';
      const normalized = colorKey(color);
      if (!normalized) return;
      if (plugin.isChecked && normalized !== plugin.color) return;
      if (plugin.color === RED && normalized !== RED) return;
      if (plugin.colorLocked && normalized !== RED) return;
      plugin.color = normalized;
      plugin.input.style.accentColor = normalized;
    }

    function removeBody(body, options = {}) {
      if (!body) return;
      const { skipStamp = false } = options;
      if (body.plugin?.isChecked && !skipStamp) {
        stampEmoji(body);
      }
      bodies.delete(body);
      const constraints = [...world.constraints];
      constraints.forEach((c) => {
        if (c.bodyA === body || c.bodyB === body) {
          World.remove(world, c);
        }
      });
      if (body.plugin?.element) {
        body.plugin.element.remove();
      }
      World.remove(world, body);
    }

    function stampEmoji(body) {
      const field = document.getElementById('emoji-field');
      if (!field) return;
      const color = body.plugin?.color || body.plugin?.input?.style?.accentColor || '#7ad7f0';
      if (body.plugin?.isChecked) {
        addPip(color);
      }
      const span = document.createElement('span');
      span.className = 'stamp';
      span.textContent = '☑️';
      span.style.color = color;
      span.style.left = `${body.position.x}px`;
      span.style.top = `${body.position.y}px`;
      field.appendChild(span);
    }

    function addPip(color) {
      if (!pipPanel) return;
      const row = ensurePipRow(color);
      if (!row) return;
      const meter = row.querySelector('.pip-meter');
      if (!meter) return;
      const state = ensurePipState(color);

      function makePip(level) {
        const pip = document.createElement('span');
        pip.className = `pip level-${level}`;
        pip.dataset.level = `${level}`;
        pip.style.background = color;
        pip.title = ['Pip', 'Super', 'Mega', 'Ultra', 'Giga', 'Tera', 'Omega'][level] || 'Pip';
        return pip;
      }

      function addLevel(level) {
        const pip = makePip(level);
        meter.appendChild(pip);
        state.levels[level] = (state.levels[level] || 0) + 1;
      }

      function consume(level, count) {
        const nodes = Array.from(meter.querySelectorAll(`.pip[data-level="${level}"]`));
        const toRemove = nodes.slice(0, count);
        toRemove.forEach((n) => n.remove());
        state.levels[level] = Math.max(0, (state.levels[level] || 0) - toRemove.length);
      }

      addLevel(0);

      for (let level = 0; level < 6; level++) {
        while ((state.levels[level] || 0) >= 10) {
          consume(level, 10);
          addLevel(level + 1);
        }
      }

      refreshShop();
    }

    function refreshShopOptions() {
      if (!shopSelect) return;
      const knownColors = Array.from(pipState.keys());
      const options = knownColors.filter((c) => availablePoints(c) > 0);
      const existing = new Set(options);
      Array.from(shopSelect.options).forEach((opt) => {
        if (!existing.has(opt.value)) opt.remove();
      });

      options.forEach((color) => {
        const found = Array.from(shopSelect.options).find((o) => o.value === color);
        if (found) {
          found.textContent = `${colorLabels[color] || 'Color'} (${availablePoints(color)} pts)`;
          return;
        }
        const opt = document.createElement('option');
        opt.value = color;
        opt.textContent = `${colorLabels[color] || 'Color'} (${availablePoints(color)} pts)`;
        opt.style.color = color;
        shopSelect.appendChild(opt);
      });

      if (!shopSelect.value && shopSelect.options.length) {
        shopSelect.value = shopSelect.options[0].value;
      }
    }

    function refreshShopActions() {
      if (!shopActions) return;
      shopActions.innerHTML = '';
      upgrades.forEach((upgrade) => {
        const row = document.createElement('div');
        row.className = 'shop-action';

        const copy = document.createElement('div');
        copy.innerHTML = `<div class="label">${upgrade.label}</div><div class="hint">${upgrade.hint()}</div>`;

        const button = document.createElement('button');
        button.textContent = `${upgrade.cost} pts`;
        button.addEventListener('click', () => {
          const color = shopSelect?.value;
          if (!color) return;
          if (availablePoints(color) < upgrade.cost) return;
          if (!upgrade.canApply()) return;
          spentPoints.set(colorKey(color), (spentPoints.get(colorKey(color)) || 0) + upgrade.cost);
          upgrade.apply();
          refreshShop();
        });

        row.appendChild(copy);
        row.appendChild(button);
        shopActions.appendChild(row);
      });
    }

    function refreshShopPoints() {
      if (!shopPoints) return;
      const color = shopSelect?.value;
      const current = color ? availablePoints(color) : 0;
      shopPoints.textContent = `${current} pts`;
      if (color && shopSelect) {
        const option = Array.from(shopSelect.options).find((o) => o.value === color);
        if (option) option.textContent = `${colorLabels[color] || 'Color'} (${availablePoints(color)} pts)`;
      }
    }

    function refreshShop() {
      refreshShopOptions();
      refreshShopActions();
      refreshShopPoints();
      if (shopActions) {
        Array.from(shopActions.children).forEach((row, idx) => {
          const button = row.querySelector('button');
          const upgrade = upgrades[idx];
          if (button && upgrade) {
            const color = shopSelect?.value;
            const enough = color ? availablePoints(color) >= upgrade.cost : false;
            button.disabled = !enough || !upgrade.canApply();
            button.textContent = upgrade.canApply() ? `${upgrade.cost} pts` : 'Maxed';
          }
        });
      }
    }

    function mergeBodies(a, b) {
      if (!a?.plugin || !b?.plugin) return;
      if (!bodies.has(a) || !bodies.has(b)) return;
      if (!a.plugin.canMerge || !b.plugin.canMerge) return;

      const colorA = colorKey(a.plugin.color || '#7ad7f0');
      const colorB = colorKey(b.plugin.color || '#7ad7f0');
      if (!colorA || !colorB) return;

      const color = blendColors(colorA, colorB);
      if (!color) return;

      const position = {
        x: (a.position.x + b.position.x) / 2,
        y: (a.position.y + b.position.y) / 2
      };
      const size = Math.max(20, Math.min(52, (a.plugin.size + b.plugin.size) / 2));
      const isChecked = !!(a.plugin.isChecked || b.plugin.isChecked);
      const name = randomName();

      const element = document.createElement('label');
      element.className = 'checkbox';
      element.style.width = `${size}px`;
      element.style.height = `${size}px`;
      element.title = name;
      element.dataset.name = name;

      const nameLabel = document.createElement('div');
      nameLabel.className = 'name-label';
      nameLabel.textContent = name;

      const input = document.createElement('input');
      input.type = 'checkbox';

      element.appendChild(nameLabel);
      element.appendChild(input);
      scene.appendChild(element);

      const body = Bodies.rectangle(position.x, position.y, size, size, {
        restitution: 0.72,
        friction: 0.005,
        frictionStatic: 0.001,
        frictionAir: 0.012,
        chamfer: 4,
        label: 'checkbox'
      });

      body.plugin = {
        element,
        input,
        isChecked,
        isStuck: false,
        isFrozen: false,
        isExploding: false,
        isOverdrive: false,
        size,
        color,
        colorLocked: isChecked || color === '#ff4d4f',
        explosionStart: 0,
        lastExplosion: 0,
        lastBoost: 0,
        canMerge: false
      };

      input.checked = isChecked;
      if (isChecked) {
        Body.setAngularVelocity(body, body.angularVelocity * 0.4);
        body.frictionAir = 0.02;
        body.friction = 0.001;
        body.frictionStatic = 0.0005;
      }

      input.addEventListener('change', () => {
        if (body.plugin.isChecked) {
          input.checked = true;
          return;
        }
        body.plugin.isChecked = true;
        body.plugin.colorLocked = true;
        updateColor(body, body.plugin.color);
        Body.setAngularVelocity(body, body.angularVelocity * 0.4);
        body.frictionAir = 0.02;
        body.friction = 0.001;
        body.frictionStatic = 0.0005;
      });

      const vel = {
        x: (a.velocity.x + b.velocity.x) / 2,
        y: (a.velocity.y + b.velocity.y) / 2
      };
      Body.setVelocity(body, vel);
      Body.setAngularVelocity(body, (a.angularVelocity + b.angularVelocity) / 2);
      updateColor(body, color);

      bodies.add(body);
      World.add(world, body);

      setTimeout(() => {
        if (bodies.has(body) && body.plugin) {
          body.plugin.canMerge = true;
        }
      }, 200);

      removeBody(a, { skipStamp: true });
      removeBody(b, { skipStamp: true });
    }

    function limitSpeed(body) {
      if (body.isStatic) return;
      const maxSpeed = 8 * settings.speedMultiplier;
      const maxSpin = 1.8 * settings.spinMultiplier;
      const speed = Vector.magnitude(body.velocity);
      if (speed > maxSpeed) {
        Body.setVelocity(body, Vector.mult(Vector.normalise(body.velocity), maxSpeed));
      }
      if (Math.abs(body.angularVelocity) > maxSpin) {
        Body.setAngularVelocity(body, Math.sign(body.angularVelocity) * maxSpin);
      }
    }

    function triggerOverdrive(body) {
      const plugin = body.plugin;
      if (!plugin || plugin.isExploding || plugin.isChecked) return false;
      const speed = Vector.magnitude(body.velocity);
      const threshold = 7.5;
      if (speed <= threshold) return false;
      const now = performance.now();
      if (plugin.lastBoost && now - plugin.lastBoost < 500) return false;
      plugin.lastBoost = now;
      plugin.isOverdrive = true;

      const factor = 1.12;
      Body.scale(body, factor, factor);
      plugin.size *= factor;
      plugin.element.style.width = `${plugin.size}px`;
      plugin.element.style.height = `${plugin.size}px`;
      plugin.element.classList.add('overdrive');
      updateColor(body, '#52ff8f');

      Body.setVelocity(body, { x: 0, y: 0 });
      Body.setAngularVelocity(body, 0);
      return true;
    }

    function shrinkIfSpinningFast(body) {
      if (!body.plugin || body.isStatic || body.plugin.isFrozen || body.plugin.isExploding || body.plugin.isChecked) return false;
      const spin = Math.abs(body.angularVelocity);
      const threshold = 2.4 * settings.spinMultiplier;
      if (spin <= threshold) return false;
      const factor = 0.985;
      const newSize = body.plugin.size * factor;
      if (newSize < 10) {
        removeBody(body);
        return true;
      }
      Body.scale(body, factor, factor);
      Body.setAngularVelocity(body, 0);
      body.plugin.size = newSize;
      body.plugin.element.style.width = `${newSize}px`;
      body.plugin.element.style.height = `${newSize}px`;
      return false;
    }

    Events.on(engine, 'beforeUpdate', () => {
      bodies.forEach((body) => {
        if (body.plugin && (body.position.y < topLimit || body.position.y > bottomLimit)) {
          removeBody(body);
          return;
        }

        if (body.plugin?.isFrozen) {
          limitSpeed(body);
          return;
        }

        const boosted = triggerOverdrive(body);
        if (boosted) {
          limitSpeed(body);
          return;
        }

        const removed = shrinkIfSpinningFast(body);
        if (removed) return;

        if (body.plugin?.isExploding) {
          Body.setAngularVelocity(body, 0);
          const now = performance.now();
          const start = body.plugin.explosionStart || now;
          const elapsed = now - start;
          if (elapsed < 250) {
            // Initial downward blast
            const blast = 0.006 * body.mass;
            Body.applyForce(body, body.position, { x: 0, y: blast });
          } else {
            const t = Math.max(0, (elapsed - 250) / 1000); // seconds after blast
            const base = -0.00025 * body.mass;
            const ramp = -0.0005 * Math.min(t, 5) * body.mass; // accelerates upward over time
            Body.applyForce(body, body.position, { x: 0, y: base + ramp });
          }
        } else if (body.plugin?.isChecked) {
          const dropForce = 0.0012 * body.mass;
          Body.applyForce(body, body.position, { x: 0, y: dropForce });
        } else {
          applyCenterAttraction(body);
        }

        limitSpeed(body);
      });
    });

    function lockBody(body) {
      if (!body.plugin || body.plugin.isStuck) return;
      body.plugin.isStuck = true;
      Body.setVelocity(body, { x: 0, y: 0 });
      Body.setAngularVelocity(body, 0);
      Body.set(body, { frictionAir: 0.035, friction: 0.2, restitution: 0.05 });
    }

    function freezeBody(target, anchor) {
      if (!target?.plugin || target.plugin.isFrozen) return;
      target.plugin.isFrozen = true;

      Body.setVelocity(target, { x: 0, y: 0 });
      Body.setAngularVelocity(target, 0);

      const group = anchor?.collisionFilter?.group || nextGroup();
      if (anchor) {
        Body.set(anchor, { collisionFilter: { ...anchor.collisionFilter, group } });
      }
      Body.set(target, {
        collisionFilter: { ...target.collisionFilter, group },
        frictionAir: 0.08,
        friction: 0.2,
        restitution: 0.05
      });

      if (anchor) {
        const constraint = Constraint.create({
          bodyA: target,
          bodyB: anchor,
          length: 0,
          stiffness: 1,
          angularStiffness: 1,
          damping: 0.35
        });
        World.add(world, constraint);
      }
    }

    function isFloor(body) {
      return body?.label === 'floor';
    }

    function isCeiling(body) {
      return body?.label === 'ceiling';
    }

    function collectCluster(seed) {
      const visited = new Set();
      const queue = [seed];
      while (queue.length) {
        const current = queue.pop();
        if (!current || visited.has(current)) continue;
        visited.add(current);
        world.constraints.forEach((c) => {
          const { bodyA, bodyB } = c;
          if (bodyA === current && bodyB && !visited.has(bodyB)) queue.push(bodyB);
          if (bodyB === current && bodyA && !visited.has(bodyA)) queue.push(bodyA);
        });
      }
      return visited;
    }

    function freezeCluster(seed) {
      if (!seed?.plugin || seed.plugin.isFrozen) return;
      const group = seed.collisionFilter?.group || nextGroup();
      const cluster = collectCluster(seed);
      cluster.forEach((body) => {
        Body.setVelocity(body, { x: 0, y: 0 });
        Body.setAngularVelocity(body, 0);
        Body.set(body, {
          isStatic: true,
          collisionFilter: { ...body.collisionFilter, group }
        });
        if (body.plugin) {
          body.plugin.isFrozen = true;
          body.plugin.isStuck = true;
        }
      });
    }

    function isBlank(body) {
      return body?.plugin && !body.plugin.isChecked;
    }

    function explode(body, neighbors) {
      const now = performance.now();
      if (body.plugin.lastExplosion && now - body.plugin.lastExplosion < 400) return;
      body.plugin.lastExplosion = now;
      if (!body.plugin.isExploding) {
        body.plugin.isExploding = true;
        body.plugin.explosionStart = now;
        const { element, input } = body.plugin;
        element.classList.add('exploding');
        body.plugin.colorLocked = true;
        updateColor(body, '#ff4d4f');
        Body.setAngularVelocity(body, 0);
      }

      const origin = body.position;
      const blast = 0.08 * settings.explosionMultiplier;

      neighbors.forEach((other) => {
        if (!other?.position) return;
        const dir = Vector.normalise(Vector.sub(other.position, origin));
        const force = Vector.mult(dir, blast * other.mass);
        Body.applyForce(other, other.position, force);
        Body.setAngularVelocity(other, other.angularVelocity + (Math.random() - 0.5) * 1.6);
      });

      const selfKick = Vector.mult({ x: Math.random() - 0.5, y: Math.random() - 0.5 }, blast * body.mass * 1.6);
      Body.applyForce(body, body.position, selfKick);
      Body.setAngularVelocity(body, body.angularVelocity + (Math.random() - 0.5) * 2.2);
    }

    function stickIfChecked(candidate, other, contactPoint) {
      const plugin = candidate.plugin;
      if (!plugin?.isChecked || plugin.isStuck) return;

      const anchor = contactPoint || candidate.position;
      const group = nextGroup();
      lockBody(candidate);
      Body.set(candidate, {
        collisionFilter: { ...candidate.collisionFilter, group }
      });

      if (other && !other.isStatic) {
        const constraint = Constraint.create({
          bodyA: candidate,
          bodyB: other,
          pointA: { x: anchor.x - candidate.position.x, y: anchor.y - candidate.position.y },
          pointB: { x: anchor.x - other.position.x, y: anchor.y - other.position.y },
          length: 0,
          stiffness: 1,
          angularStiffness: 1,
          damping: 0.25
        });
        World.add(world, constraint);

        if (other.plugin && !other.plugin.isStuck) {
          lockBody(other);
        }
        Body.set(other, {
          collisionFilter: { ...other.collisionFilter, group }
        });
      } else {
        const constraint = Constraint.create({
          bodyA: candidate,
          pointB: anchor,
          length: 0,
          stiffness: 1,
          angularStiffness: 1,
          damping: 0.25
        });
        World.add(world, constraint);
      }
    }

    Events.on(engine, 'collisionStart', (event) => {
      event.pairs.forEach((pair) => {
        const contact = pair.collision.supports[0];
        stickIfChecked(pair.bodyA, pair.bodyB, contact);
        stickIfChecked(pair.bodyB, pair.bodyA, contact);
      });
    });

    // Keep evaluating sticky contact even if the box was already resting when checked (e.g., on the floor).
    Events.on(engine, 'collisionActive', (event) => {
      const neighborMap = new Map();
      const pendingMerges = [];

      event.pairs.forEach((pair) => {
        const contact = pair.collision.supports[0];
        stickIfChecked(pair.bodyA, pair.bodyB, contact);
        stickIfChecked(pair.bodyB, pair.bodyA, contact);

        if (pair.bodyA.plugin?.isChecked) freezeBody(pair.bodyB, pair.bodyA);
        if (pair.bodyB.plugin?.isChecked) freezeBody(pair.bodyA, pair.bodyB);

        if (isFloor(pair.bodyA) && pair.bodyB.plugin?.isChecked) {
          freezeCluster(pair.bodyB);
        }
        if (isFloor(pair.bodyB) && pair.bodyA.plugin?.isChecked) {
          freezeCluster(pair.bodyA);
        }

        if (isCeiling(pair.bodyA) && pair.bodyB.plugin) {
          removeBody(pair.bodyB);
        }
        if (isCeiling(pair.bodyB) && pair.bodyA.plugin) {
          removeBody(pair.bodyA);
        }

        if (pair.bodyA.plugin?.isExploding && !pair.bodyB.plugin?.isChecked && !pair.bodyB.plugin?.isExploding) {
          explode(pair.bodyB, [pair.bodyA]);
        }
        if (pair.bodyB.plugin?.isExploding && !pair.bodyA.plugin?.isChecked && !pair.bodyA.plugin?.isExploding) {
          explode(pair.bodyA, [pair.bodyB]);
        }

        const aBlank = isBlank(pair.bodyA);
        const bBlank = isBlank(pair.bodyB);
        if (aBlank && bBlank) {
          if (!neighborMap.has(pair.bodyA)) neighborMap.set(pair.bodyA, new Set());
          if (!neighborMap.has(pair.bodyB)) neighborMap.set(pair.bodyB, new Set());
          neighborMap.get(pair.bodyA).add(pair.bodyB);
          neighborMap.get(pair.bodyB).add(pair.bodyA);
        }

        const colorA = pair.bodyA.plugin?.color;
        const colorB = pair.bodyB.plugin?.color;
        const checkedA = !!pair.bodyA.plugin?.isChecked;
        const checkedB = !!pair.bodyB.plugin?.isChecked;
        const canMergeA = !!pair.bodyA.plugin?.canMerge;
        const canMergeB = !!pair.bodyB.plugin?.canMerge;
        if (
          checkedA && checkedB &&
          canMergeA && canMergeB
        ) {
          pendingMerges.push([pair.bodyA, pair.bodyB]);
        }
      });

      neighborMap.forEach((neighbors, body) => {
        if (neighbors.size >= 3) {
          explode(body, neighbors);
        }
      });

      pendingMerges.forEach(([a, b]) => mergeBodies(a, b));
    });

    function boundsOverlap(a, b) {
      if (!a?.bounds || !b?.bounds) return false;
      return !(
        a.bounds.min.x > b.bounds.max.x ||
        a.bounds.max.x < b.bounds.min.x ||
        a.bounds.min.y > b.bounds.max.y ||
        a.bounds.max.y < b.bounds.min.y
      );
    }

    function scanCheckedMerges() {
      const candidates = [];
      bodies.forEach((body) => {
        if (
          body.plugin &&
          body.plugin.canMerge &&
          body.plugin.isChecked
        ) {
          candidates.push(body);
        }
      });

      for (let i = 0; i < candidates.length; i++) {
        for (let j = i + 1; j < candidates.length; j++) {
          const a = candidates[i];
          const b = candidates[j];
          if (!bodies.has(a) || !bodies.has(b)) continue;
          if (boundsOverlap(a, b)) {
            mergeBodies(a, b);
          }
        }
      }
    }

    Events.on(engine, 'afterUpdate', () => {
      scanCheckedMerges();
    });

    function syncElements() {
      bodies.forEach((body) => {
        const { element, size = 36 } = body.plugin;
        const half = size / 2;
        element.style.transform = `translate(${body.position.x - half}px, ${body.position.y - half}px) rotate(${body.angle}rad)`;
        const nameLabel = element.querySelector('.name-label');
        if (nameLabel) {
          nameLabel.style.transform = `translate(-50%, -4px) rotate(${ -body.angle }rad)`;
        }
      });
      requestAnimationFrame(syncElements);
    }

    Runner.run(runner, engine);
    requestAnimationFrame(syncElements);

    resetSpawner();
    for (let i = 0; i < 10; i++) {
      spawnCheckbox();
    }
    spawnWave();
  </script>
</body>
</html>
